# Атомарная запись в n ячеек

##### Случай двух потоков
*Для удобства будем нумеровать потоки с 1.*
Заведём три ячейки r[0], r[1], r[2]. Изначально они все равны нулю. Каждый поток с номером v пишет в ячейки r[0] и r[v] свой номер. Рассмотрим какие состояния ячеек могут быть.

| #состояния | r[0] | r[1] | r[2] |
|---|---|---|---|
|1|1|1|0|
|2|2|1|2|
|3|2|0|2|
|4|1|1|2|

Вывод будем определять по первой записи ячейки r[0].

В состоянии 1 поток #1 сделал запись, а поток #2 нет, о чём свидетельствует r[2]. Значит, первым запись сделал поток #1. Decide может быть окончен с 1. После этого состояния может наступить только 2 состояние, когда запись сделает 2 поток. Он увидит, что r[0] равно его номеру, но r[1] не равняется 0, потэтому он писал вторым и вернёт 1. Из таких же соображений поток #1 поймёт, что в этой ситуации нужно вернуть 1. Таким образом, в случае, когда перый поток пишет првым оба потока выводят 1.

Не умаляя общности, то же можно продетать для 3 и 4 состояний и понять, что в случае, когда второй поток пишет првым, оба потока выводят 2.

Мы доказали свойство `agreement`. Так как мы выводим номер первого потока, что сделал `Multy-Write`, то свойство `valility` тоже выполнено. Наш алгопитм работает за константное время и заканчивается вне зависимости от результата исполнения другого потока, поэтому свойство `wait-free termination` тоже выполнено.

Код Decide :
```python
#v - номер потока
#Multi-Write(r1,v1,r2,v2)
Multi-Write(r[0], v, r[v], v)
if r[0] == v AND r[3 - v] == 0
	return v
else 
	return 3 - r[0]
```

##### Случай n потоков
Заведём регистры $r_i$ для каждого из потоков и регистры $r_{ij}$ i!=j для каждой пары потоков. Под $r_{ij}$ и $r_{ji}$ понимантся один и тот же регистр. Каждый поток #n пишет свой номер в $r_n$ и во все $r_{nj}$, где j - произвольно (заметим, что число ячеек равно n). Таким образом, для каждой прары потоков i и j, можно выделить ячейки $r_{ij}$, $r_i$ и $r_j$, которые моделируют ситуацию с 2 потоками (r[0], r[1] и r[2] соответственно), а значит, для каждой пары можно выделить победителя. Сторя граф, где вершины - потоки, ребро из a в b означает a выиграл b, можно выделить первого победителя. В него не будут вести рёбра и из него будет выходить хотябы одно ребро.

Победитель один для всех, значит `agreement` есть. Так как мы выводим номер первого потока, что сделал `Multy-Write`, то свойство `valility` выполнено. Граф строится за константное время, значит свойство `wait-free termination` выполнено.